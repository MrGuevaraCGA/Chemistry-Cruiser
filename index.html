<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chemistry Cruiser: Ultimate Safety Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* HUD & UI */
        .hud { 
            position: absolute; top: 20px; left: 20px; right: 20px; 
            display: flex; justify-content: space-between; pointer-events: none; z-index: 10;
        }
        .hud-panel {
            background: rgba(15, 23, 42, 0.6); 
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 20px; 
            border-radius: 8px;
            color: #fff;
            transform: skew(-10deg);
            min-width: 100px;
        }
        .hud-text { transform: skew(10deg); font-weight: 800; font-size: 1.2rem; }
        .hud-label { color: #94a3b8; font-size: 0.7rem; text-transform: uppercase; display: block; }
        
        /* Health Bar */
        #health-bar-container {
            width: 200px; height: 10px; background: #333; border-radius: 5px; margin-top: 5px; overflow: hidden;
        }
        #health-bar {
            width: 100%; height: 100%; background: #22c55e; transition: width 0.2s, background 0.2s;
        }

        /* Message Overlay (Safety/Quiz) */
        .modal-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); 
            display: none; justify-content: center; align-items: center; 
            z-index: 50; backdrop-filter: blur(5px);
        }
        .modal-content { 
            background: #1e293b; padding: 2rem; border-radius: 1rem; max-width: 600px; width: 90%; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8); text-align: center; border: 1px solid #334155;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* Start Screen (Garage) */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f172a 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white;
        }
        .vehicle-card {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.2s;
            width: 120px; text-align: center;
        }
        .vehicle-card:hover, .vehicle-card.selected {
            background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; transform: translateY(-5px);
        }
        
        .color-btn {
            width: 40px; height: 40px; rounded-full; cursor: pointer; border: 2px solid #666; border-radius: 50%;
            transition: transform 0.2s, border-color 0.2s;
        }
        .color-btn:hover { transform: scale(1.1); }
        .color-btn.selected { border-color: white; transform: scale(1.1); box-shadow: 0 0 10px white; }

        /* Safety Alert */
        #safety-alert {
            position: absolute; top: 20%; width: 100%; text-align: center;
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 40;
        }
        .safety-box {
            display: inline-block; background: rgba(220, 38, 38, 0.9); color: white;
            padding: 15px 30px; border-radius: 50px; font-weight: bold; font-size: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 2px solid white;
        }

        .btn { 
            background: #3b82f6; color: white; padding: 12px 30px; border-radius: 8px; 
            border: none; cursor: pointer; font-weight: bold; margin-top: 20px;
        }
        .btn:hover { background: #2563eb; }

        /* Mobile Controls */
        #mobile-controls {
            display: none; position: absolute; bottom: 20px; width: 100%; height: 150px;
            pointer-events: none; justify-content: space-between; padding: 0 30px; z-index: 20;
        }
        .d-btn {
            pointer-events: auto; width: 60px; height: 60px; background: rgba(255,255,255,0.2);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 24px; border: 1px solid rgba(255,255,255,0.4); backdrop-filter: blur(4px);
        }
        @media (max-width: 768px) { #mobile-controls { display: flex; } }
    </style>
</head>
<body>

<div id="game-container"></div>

<!-- HUD -->
<div class="hud">
    <div class="hud-panel">
        <div class="hud-text">
            <span class="hud-label">Vehicle Condition</span>
            <div id="health-bar-container"><div id="health-bar"></div></div>
        </div>
    </div>
    <div class="hud-panel" style="text-align: right;">
        <div class="hud-text">
            <span class="hud-label">Score / Level</span>
            <span class="hud-value" id="score-display">0</span> <span class="text-gray-400 text-sm">| Lvl <span id="level-display">1</span></span>
        </div>
        <div class="hud-text mt-2 text-sm text-yellow-400" id="weather-display">‚òÄÔ∏è Clear</div>
    </div>
</div>

<!-- Safety Alert Pop-up -->
<div id="safety-alert">
    <div class="safety-box">‚ö†Ô∏è SPEED KILLS - SLOW DOWN!</div>
</div>

<!-- Quiz Modal -->
<div id="quiz-modal" class="modal-overlay">
    <div class="modal-content">
        <h2 class="text-2xl font-bold text-white mb-4" id="quiz-question">Question?</h2>
        <div id="quiz-options" class="grid gap-2"></div>
        <div id="quiz-feedback" class="mt-4 font-bold hidden text-lg"></div>
        <button id="quiz-continue" class="btn hidden w-full" onclick="closeQuiz()">Continue Safely</button>
    </div>
</div>

<!-- Game Over Modal -->
<div id="game-over-modal" class="modal-overlay">
    <div class="modal-content border-red-500">
        <h1 class="text-4xl font-black text-red-500 mb-2">VEHICLE DESTROYED</h1>
        <p class="text-gray-300 mb-6">You drove too fast and ignored safety warnings.</p>
        <div class="text-2xl font-bold mb-6 text-white" id="final-score">Score: 0</div>
        <button class="btn bg-red-600 hover:bg-red-700 w-full" onclick="location.reload()">Back to Garage</button>
    </div>
</div>

<!-- Start Screen / Garage -->
<div id="start-screen">
    <h1 class="text-5xl font-black mb-2 italic bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-green-400">CHEMISTRY CRUISER</h1>
    <p class="text-gray-400 mb-8 tracking-widest text-sm">ULTIMATE SAFETY EDITION</p>
    
    <div class="bg-gray-900/80 p-8 rounded-2xl border border-gray-700 backdrop-blur-md max-w-4xl w-full">
        <h2 class="text-xl font-bold mb-4 text-white">1. Choose Your Vehicle</h2>
        <div class="flex flex-wrap justify-center gap-4 mb-8" id="vehicle-selector">
            <div class="vehicle-card selected" onclick="selectVehicle('sedan', this)">
                <div class="text-3xl mb-2">üöó</div>
                <div class="font-bold text-sm">Sedan</div>
            </div>
            <div class="vehicle-card" onclick="selectVehicle('f1', this)">
                <div class="text-3xl mb-2">üèéÔ∏è</div>
                <div class="font-bold text-sm">F1 Racer</div>
            </div>
            <div class="vehicle-card" onclick="selectVehicle('truck', this)">
                <div class="text-3xl mb-2">üöö</div>
                <div class="font-bold text-sm">Hauler</div>
            </div>
            <div class="vehicle-card" onclick="selectVehicle('van', this)">
                <div class="text-3xl mb-2">üöê</div>
                <div class="font-bold text-sm">Hippy Van</div>
            </div>
            <div class="vehicle-card" onclick="selectVehicle('heli', this)">
                <div class="text-3xl mb-2">üöÅ</div>
                <div class="font-bold text-sm">Heli-Car</div>
            </div>
        </div>

        <h2 class="text-xl font-bold mb-4 text-white">2. Paint Job</h2>
        <div class="flex justify-center gap-4 mb-8" id="color-selector">
            <div class="color-btn bg-red-500 selected" onclick="setPaint(0xff0000, this)"></div>
            <div class="color-btn bg-blue-500" onclick="setPaint(0x3b82f6, this)"></div>
            <div class="color-btn bg-green-500" onclick="setPaint(0x22c55e, this)"></div>
            <div class="color-btn bg-purple-500" onclick="setPaint(0xa855f7, this)"></div>
            <div class="color-btn bg-yellow-500" onclick="setPaint(0xeab308, this)"></div>
            <div class="color-btn bg-white" onclick="setPaint(0xffffff, this)"></div>
            <div class="color-btn bg-gray-900" onclick="setPaint(0x111111, this)"></div>
        </div>

        <button class="btn w-full text-xl py-4 shadow-lg shadow-blue-500/30" onclick="initGame()">START ENGINE</button>
    </div>
</div>

<div id="mobile-controls">
    <div class="flex flex-col gap-2 justify-center">
        <div class="d-btn" id="btn-up">‚ñ≤</div>
        <div class="d-btn" id="btn-down">‚ñº</div>
    </div>
    <div class="flex gap-2 items-end">
        <div class="d-btn" id="btn-left">‚óÄ</div>
        <div class="d-btn" id="btn-right">‚ñ∂</div>
    </div>
</div>

<script>
    // --- Data: Questions ---
    const questions = [
        { q: "Which statement best describes matter?", a: "Anything that has mass and takes up space", options: ["Anything that has mass and takes up space", "Only solids and liquids", "Energy and light", "Anything visible to the eye"] },
        { q: "Protons are located in which part of an atom?", a: "Nucleus", options: ["Electron Cloud", "Nucleus", "Outer Shell", "They orbit the nucleus"] },
        { q: "What is the charge of a neutron?", a: "Neutral (No charge)", options: ["Positive", "Negative", "Neutral (No charge)", "Variable"] },
        { q: "In a solid, particles:", a: "Vibrate in a fixed position", options: ["Move freely and quickly", "Slide past one another", "Vibrate in a fixed position", "Are completely motionless"] },
        { q: "Which state of matter has no fixed shape and no fixed volume?", a: "Gas", options: ["Solid", "Liquid", "Gas", "Plasma"] },
        { q: "A physical change:", a: "Does not change the substance's identity", options: ["Creates a new substance", "Changes the chemical composition", "Is irreversible", "Does not change the substance's identity"] },
        { q: "According to the Law of Conservation of Matter:", a: "Matter is neither created nor destroyed", options: ["Matter is destroyed in fire", "Mass increases during reactions", "Matter is neither created nor destroyed", "Matter turns into pure energy easily"] },
        { q: "A mixture is defined as:", a: "Two or more substances physically combined", options: ["Two or more substances chemically bonded", "Two or more substances physically combined", "A pure substance", "A single element"] },
        { q: "Filtration works because:", a: "It separates based on particle size", options: ["It separates based on magnetism", "It separates based on particle size", "It separates based on boiling point", "It creates a chemical reaction"] },
        { q: "Magnetism can separate:", a: "Iron filings from sand", options: ["Salt from water", "Oil from water", "Iron filings from sand", "Sugar from flour"] },
        { q: "Trail mix is an example of:", a: "Heterogeneous mixture", options: ["Homogeneous mixture", "Compound", "Element", "Heterogeneous mixture"] },
        { q: "Saltwater is an example of:", a: "Homogeneous mixture (Solution)", options: ["Heterogeneous mixture", "Compound", "Homogeneous mixture (Solution)", "Element"] },
        { q: "Burning a log appears to lose mass because:", a: "Gases are released into the air", options: ["The matter is destroyed", "The atoms disappear", "Gases are released into the air", "Fire eats the wood"] },
        { q: "Which is a sign that a chemical reaction has occurred?", a: "Formation of a precipitate or gas", options: ["Change in shape", "Melting", "Formation of a precipitate or gas", "Breaking into pieces"] },
        { q: "The smallest unit of matter that retains the properties of an element is:", a: "Atom", options: ["Molecule", "Atom", "Electron", "Proton"] }
    ];

    const safetyMessages = [
        "Speed Kills - SLOW DOWN!",
        "Eyes on the road!",
        "Watch your stopping distance!",
        "Arrive alive - Don't drink and drive!",
        "Seatbelts save lives!",
        "Beware of aquaplaning in rain!"
    ];

    // --- Game Variables ---
    let scene, camera, renderer, car, cityGroup;
    let itemsGroup, obstaclesGroup, buildingsGroup, tunnelsGroup, treesGroup;
    let particleSystems = []; // Rain, Snow, Smoke
    let smokeEmitter, fireEmitter;
    
    let gameActive = false;
    let score = 0;
    let itemsCollected = 0;
    let level = 1;
    let clock = new THREE.Clock();
    let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false, " ": false };
    
    // Physics
    let speed = 0;
    let maxSpeed = 0.6; // Slower speed
    let turnSpeed = 0.03;
    let yVelocity = 0;
    const gravity = -0.015;
    const jumpForce = 0.4;
    
    // Vehicle State
    let selectedVehicleType = 'sedan';
    let vehicleColor = 0xff0000;
    let health = 100;
    let isHovering = false; // For Heli
    
    // Environment
    const CITY_SIZE = 1500;
    let time = 0; // Total time
    let dayTime = 0; // 0 to 1 cycle
    const dayDuration = 180; // Seconds for full cycle (120s day + 60s night)
    
    // Weather
    const WEATHER_TYPES = ['Clear', 'Breezy', 'Rain', 'Storm', 'Snow'];
    let currentWeatherIndex = 0;
    let nextWeatherIndex = 0;
    let weatherBlend = 0;
    let weatherTimer = 0;
    const WEATHER_CHANGE_INTERVAL = 30; // Seconds

    // --- Setup Selection ---
    function selectVehicle(type, el) {
        selectedVehicleType = type;
        document.querySelectorAll('.vehicle-card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
    }

    function setPaint(color, el) {
        vehicleColor = color;
        document.querySelectorAll('.color-btn').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
    }
    
    // Explicitly expose to window to ensure onclick works
    window.selectVehicle = selectVehicle;
    window.setPaint = setPaint;
    window.initGame = initGame;

    // --- Terrain Helper ---
    function getTerrainHeight(x, z) {
        // Larger hills for jumping, plus some smaller noise
        return (Math.sin(x * 0.01) * 12 + Math.cos(z * 0.01) * 12) + 
               (Math.sin(x * 0.03) * 4 + Math.cos(z * 0.03) * 4);
    }

    // --- Initialization ---
    function initGame() {
        document.getElementById('start-screen').style.display = 'none';
        
        // Reset Logic
        level = 1; score = 0; itemsCollected = 0; health = 100;
        yVelocity = 0; speed = 0;
        updateUI();
        
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);

        // Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        const container = document.getElementById('game-container');
        container.innerHTML = ''; 
        container.appendChild(renderer.domElement);

        // Lighting (Day/Night controlled)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.name = "hemiLight";
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.name = "dirLight";
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = true;
        // Large shadow map
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // World Generation
        createEnvironment();
        createCar();
        createParticles(); // Weather + Damage

        // Events
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        setupMobileControls();

        gameActive = true;
        animate();
    }

    function createEnvironment() {
        cityGroup = new THREE.Group();
        buildingsGroup = new THREE.Group();
        tunnelsGroup = new THREE.Group();
        itemsGroup = new THREE.Group();
        obstaclesGroup = new THREE.Group();
        treesGroup = new THREE.Group();
        
        // Terrain
        const floorGeo = new THREE.PlaneGeometry(CITY_SIZE, CITY_SIZE, 100, 100);
        const posAttribute = floorGeo.attributes.position;
        const colors = [];
        const darkGray = new THREE.Color(0x222222);
        const parkGreen = new THREE.Color(0x2d5a27);

        for (let i = 0; i < posAttribute.count; i++) {
            const x = posAttribute.getX(i);
            const y = posAttribute.getY(i); // Local Y is Z in world map logic for height
            const z = getTerrainHeight(x, -y); 
            posAttribute.setZ(i, z);
            
            // Vertex Colors for Parks vs Roads
            // Simple noise-based parks
            const noise = Math.sin(x*0.02) * Math.cos(y*0.02);
            if(noise > 0.5) {
                colors.push(parkGreen.r, parkGreen.g, parkGreen.b);
            } else {
                colors.push(darkGray.r, darkGray.g, darkGray.b);
            }
        }
        floorGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        floorGeo.computeVertexNormals();
        
        const floorMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        cityGroup.add(floor);

        // Buildings (Varied Character)
        const baseGeo = new THREE.BoxGeometry(1,1,1);
        
        for (let i = 0; i < 150; i++) {
            const x = (Math.random() - 0.5) * CITY_SIZE * 0.8;
            const z = (Math.random() - 0.5) * CITY_SIZE * 0.8;
            if (Math.abs(x) < 50 && Math.abs(z) < 50) continue; 
            
            // Check if on "Park" land (simple check matches color logic)
            const noise = Math.sin(x*0.02) * Math.cos((-z)*0.02); // z is inverted in heightmap lookup
            if(noise > 0.5) {
                // Spawn Tree instead
                createTree(x, z);
                continue;
            }

            const groundHeight = getTerrainHeight(x, z);
            
            // Building Generation: Stacked
            const segments = Math.floor(Math.random() * 3) + 1;
            let currentH = 0;
            let currentW = Math.random() * 10 + 10;
            let currentD = Math.random() * 10 + 10;
            
            // Building Group
            const bGroup = new THREE.Group();
            bGroup.position.set(x, groundHeight, z);
            
            for(let s=0; s<segments; s++) {
                const h = Math.random() * 20 + 10;
                const mat = new THREE.MeshStandardMaterial({ 
                    color: Math.random() > 0.5 ? 0x2c3e50 : 0x34495e,
                    roughness: 0.2 
                });
                const mesh = new THREE.Mesh(baseGeo, mat);
                mesh.position.y = currentH + h/2;
                mesh.scale.set(currentW, h, currentD);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Add Windows
                if(Math.random() > 0.3) {
                    const winMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0 });
                    const win = new THREE.Mesh(baseGeo, winMat);
                    win.position.y = currentH + h/2;
                    win.scale.set(currentW+0.2, h*0.8, currentD+0.2);
                    win.userData = { isWindow: true };
                    bGroup.add(win);
                }

                bGroup.add(mesh);
                
                currentH += h;
                currentW *= 0.7; // Taper
                currentD *= 0.7;
            }
            
            buildingsGroup.add(bGroup);
        }

        // Tunnels
        const tunnelGeo = new THREE.TorusGeometry(10, 2, 16, 30, Math.PI);
        const tunnelMat = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide });
        for(let i=0; i<6; i++) {
            const t = new THREE.Mesh(tunnelGeo, tunnelMat);
            const x = (Math.random() - 0.5) * CITY_SIZE * 0.7;
            const z = (Math.random() - 0.5) * CITY_SIZE * 0.7;
            const y = getTerrainHeight(x, z);
            t.position.set(x, y, z);
            t.scale.set(1.5, 1.5, 2);
            t.rotation.y = Math.random() * Math.PI;
            tunnelsGroup.add(t);
        }

        spawnObjects();

        cityGroup.add(buildingsGroup);
        cityGroup.add(tunnelsGroup);
        cityGroup.add(itemsGroup);
        cityGroup.add(obstaclesGroup);
        cityGroup.add(treesGroup);
        scene.add(cityGroup);
    }

    function createTree(x, z) {
        const h = getTerrainHeight(x, z);
        const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 3);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.set(x, h + 1.5, z);
        
        const leavesGeo = new THREE.ConeGeometry(3, 8, 8);
        const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
        const leaves = new THREE.Mesh(leavesGeo, leavesMat);
        leaves.position.set(0, 5, 0);
        trunk.add(leaves);
        
        treesGroup.add(trunk);
    }

    function spawnObjects() {
        // Atoms
        const atomGeo = new THREE.SphereGeometry(1.5, 16, 16);
        const atomMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x0044ff, emissiveIntensity: 0.8 });
        for(let i=0; i<40; i++) {
            const item = new THREE.Mesh(atomGeo, atomMat);
            setRandomPosition(item);
            item.position.y += 2;
            itemsGroup.add(item);
        }

        // Spikes
        const spikeGeo = new THREE.ConeGeometry(1, 3, 8);
        const spikeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
        for(let i=0; i<30; i++) {
            const obs = new THREE.Mesh(spikeGeo, spikeMat);
            setRandomPosition(obs);
            obstaclesGroup.add(obs);
        }
    }

    function setRandomPosition(mesh) {
        let x = (Math.random() - 0.5) * CITY_SIZE * 0.8;
        let z = (Math.random() - 0.5) * CITY_SIZE * 0.8;
        let y = getTerrainHeight(x, z);
        mesh.position.set(x, y + 1.5, z);
    }

    function createCar() {
        car = new THREE.Group();
        car.userData = { velocity: new THREE.Vector3() };

        // Materials
        const colMat = new THREE.MeshStandardMaterial({ color: vehicleColor, metalness: 0.6, roughness: 0.2 });
        const darkMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.4, roughness: 0.5 });
        const glassMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6, metalness: 0.9, roughness: 0.0 });
        const redLight = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        if (selectedVehicleType === 'heli') {
            // IMPROVED HELICOPTER MODEL
            maxSpeed = 0.8;
            isHovering = true;
            
            // Fuselage (Egg shape)
            const bodyGeo = new THREE.SphereGeometry(2, 32, 32);
            bodyGeo.scale(1, 1, 1.8);
            const body = new THREE.Mesh(bodyGeo, colMat);
            body.position.y = 2.5;
            car.add(body);
            
            // Cockpit
            const cockpitGeo = new THREE.SphereGeometry(1.9, 32, 32);
            cockpitGeo.scale(0.9, 0.9, 1);
            const cockpit = new THREE.Mesh(cockpitGeo, glassMat);
            cockpit.position.set(0, 2.6, 1);
            car.add(cockpit);

            // Tail Boom
            const tailGeo = new THREE.CylinderGeometry(0.3, 0.6, 5);
            const tail = new THREE.Mesh(tailGeo, colMat);
            tail.rotation.x = Math.PI / 2;
            tail.position.set(0, 2.5, -3.5);
            car.add(tail);

            // Tail Fin
            const fin = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 1), colMat);
            fin.position.set(0, 3, -5.5);
            car.add(fin);

            // Tail Rotor
            const trGeo = new THREE.BoxGeometry(0.1, 1.8, 0.2);
            const tr = new THREE.Mesh(trGeo, darkMat);
            tr.position.set(0.3, 3, -5.5);
            tr.name = "tailRotor";
            car.add(tr);

            // Main Rotor Mast
            const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.8), darkMat);
            mast.position.set(0, 4.2, 0);
            car.add(mast);

            // Main Blades
            const blade1 = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, 0.6), darkMat);
            blade1.position.set(0, 4.6, 0);
            blade1.name = "rotor1";
            car.add(blade1);
            
            const blade2 = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 8), darkMat);
            blade2.position.set(0, 4.6, 0);
            blade2.name = "rotor2";
            car.add(blade2);

            // Skids
            const skidGeo = new THREE.CylinderGeometry(0.1, 0.1, 4);
            const skidMat = new THREE.MeshStandardMaterial({color: 0x555555});
            const skidL = new THREE.Mesh(skidGeo, skidMat);
            skidL.rotation.x = Math.PI/2;
            skidL.position.set(-1.2, 0.5, 0);
            car.add(skidL);
            const skidR = new THREE.Mesh(skidGeo, skidMat);
            skidR.rotation.x = Math.PI/2;
            skidR.position.set(1.2, 0.5, 0);
            car.add(skidR);
            
            // Struts
            const strutGeo = new THREE.CylinderGeometry(0.1, 0.1, 2);
            const s1 = new THREE.Mesh(strutGeo, skidMat); s1.position.set(-1.2, 1.5, 1); car.add(s1);
            const s2 = new THREE.Mesh(strutGeo, skidMat); s2.position.set(1.2, 1.5, 1); car.add(s2);
            const s3 = new THREE.Mesh(strutGeo, skidMat); s3.position.set(-1.2, 1.5, -1); car.add(s3);
            const s4 = new THREE.Mesh(strutGeo, skidMat); s4.position.set(1.2, 1.5, -1); car.add(s4);

        } else if (selectedVehicleType === 'f1') {
            maxSpeed = 1.0; 
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 5), colMat);
            b.position.y = 0.5;
            car.add(b);
            const s = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.8), darkMat);
            s.position.set(0, 1, -2);
            car.add(s);
        } else if (selectedVehicleType === 'truck') {
            maxSpeed = 0.5; 
            const b = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 6), colMat);
            b.position.y = 1.5;
            car.add(b);
            const cab = new THREE.Mesh(new THREE.BoxGeometry(2.6, 2, 2.5), colMat);
            cab.position.set(0, 2, 2);
            car.add(cab);
        } else if (selectedVehicleType === 'van') {
            const b = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2, 4.5), colMat);
            b.position.y = 1.2;
            car.add(b);
            const d = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xff00ff}));
            d.position.set(1.1, 1.5, 0);
            car.add(d);
        } else {
            // Sedan
            const b = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 4), colMat);
            b.position.y = 0.8;
            car.add(b);
            const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 2), darkMat);
            top.position.set(0, 1.6, -0.5);
            car.add(top);
        }

        if (!isHovering) {
            const wGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
            [ {x:-1.2,z:1.5}, {x:1.2,z:1.5}, {x:-1.2,z:-1.5}, {x:1.2,z:-1.5} ].forEach(pos => {
                const w = new THREE.Mesh(wGeo, darkMat);
                w.rotation.z = Math.PI/2;
                w.position.set(pos.x, 0.5, pos.z);
                car.add(w);
            });
        }

        // Headlights
        const sl = new THREE.SpotLight(0xffffee, 10, 80, 0.6, 0.5, 1);
        sl.position.set(0, 2, 1);
        sl.target.position.set(0, 0, 25);
        car.add(sl);
        car.add(sl.target);
        
        scene.add(car);

        // Attach Emitters
        const smokeGeo = new THREE.BufferGeometry();
        const smokePos = new Float32Array(50 * 3);
        smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePos, 3));
        const smokeMat = new THREE.PointsMaterial({ color: 0x555555, size: 2, transparent: true, opacity: 0 });
        smokeEmitter = new THREE.Points(smokeGeo, smokeMat);
        car.add(smokeEmitter);

        const fireGeo = new THREE.BufferGeometry();
        const firePos = new Float32Array(50 * 3);
        fireGeo.setAttribute('position', new THREE.BufferAttribute(firePos, 3));
        const fireMat = new THREE.PointsMaterial({ color: 0xff4400, size: 3, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
        fireEmitter = new THREE.Points(fireGeo, fireMat);
        car.add(fireEmitter);
    }

    function createParticles() {
        const count = 10000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        for(let i=0; i<count*3; i+=3) {
            pos[i] = (Math.random()-0.5)*200;
            pos[i+1] = Math.random()*100;
            pos[i+2] = (Math.random()-0.5)*200;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.2, transparent: true, opacity: 0 });
        const sys = new THREE.Points(geo, mat);
        scene.add(sys);
        particleSystems.push({ mesh: sys, type: 'weather', vel: new THREE.Vector3(0, -1, 0) });
    }

    // --- Core Game Loop ---
    function animate() {
        if (!gameActive) return;
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        time += delta;

        updateDayNightCycle();
        updateWeather(delta);
        updateCarPhysics(delta);
        updateEnvironment(delta);

        renderer.render(scene, camera);
    }

    function updateDayNightCycle() {
        const rawTime = (time % dayDuration) / dayDuration;
        let skyColor, lightIntensity;
        
        // Base Day/Night Colors
        const morning = new THREE.Color(0xffaa00);
        const noon = new THREE.Color(0x87CEEB);
        const evening = new THREE.Color(0xfd5e53);
        const night = new THREE.Color(0x0f172a);

        if (rawTime < 0.1) { // Sunrise
            skyColor = night.clone().lerp(morning, rawTime * 10);
            lightIntensity = rawTime * 8;
        } else if (rawTime < 0.2) { // Morning to Noon
            skyColor = morning.clone().lerp(noon, (rawTime - 0.1) * 10);
            lightIntensity = 0.8 + (rawTime - 0.1) * 2;
        } else if (rawTime < 0.6) { // Day
            skyColor = noon;
            lightIntensity = 1;
        } else if (rawTime < 0.7) { // Sunset
            skyColor = noon.clone().lerp(evening, (rawTime - 0.6) * 10);
            lightIntensity = 1 - (rawTime - 0.6) * 5;
        } else if (rawTime < 0.8) { // Dusk
            skyColor = evening.clone().lerp(night, (rawTime - 0.7) * 10);
            lightIntensity = 0.5 - (rawTime - 0.7) * 4;
        } else { // Night
            skyColor = night;
            lightIntensity = 0.1;
        }

        // Apply Weather Tint (Progressive)
        const stormColor = new THREE.Color(0x333333);
        // Blend current sky with storm color based on weather blend factor (0 to 1)
        // If weather is Rain/Storm (indices 2,3), target high blend. Else low.
        // We'll calculate a 'storminess' factor
        let storminess = 0;
        const wType = WEATHER_TYPES[currentWeatherIndex];
        const nextWType = WEATHER_TYPES[nextWeatherIndex];
        
        const getStorminess = (type) => (type === 'Rain' || type === 'Storm') ? 0.8 : (type === 'Snow' ? 0.4 : 0);
        
        const currentS = getStorminess(wType);
        const nextS = getStorminess(nextWType);
        const finalS = THREE.MathUtils.lerp(currentS, nextS, weatherBlend);

        skyColor.lerp(stormColor, finalS);
        lightIntensity *= (1 - finalS * 0.5);

        scene.background = skyColor;
        scene.fog.color = skyColor;
        // Fog density changes with weather
        scene.fog.density = 0.01 + (finalS * 0.02); 

        const sun = scene.getObjectByName("dirLight");
        sun.intensity = lightIntensity;
        sun.position.x = Math.sin(rawTime * Math.PI * 2) * 200;
        sun.position.y = Math.cos(rawTime * Math.PI * 2) * 200;

        // Window Lights logic
        buildingsGroup.children.forEach(group => {
            group.children.forEach(mesh => {
                if (mesh.userData.isWindow) {
                    mesh.material.opacity = (rawTime > 0.75 || rawTime < 0.05) ? 0.9 : 0;
                }
            });
        });
    }

    function updateWeather(delta) {
        // Timer for cycle
        weatherTimer += delta;
        if (weatherTimer > WEATHER_CHANGE_INTERVAL) {
            weatherTimer = 0;
            currentWeatherIndex = nextWeatherIndex;
            // Pick next weather (not just +1, make it semi-random but logical)
            // e.g., don't go Clear -> Storm instantly
            const r = Math.random();
            if (r < 0.3) nextWeatherIndex = 0; // Clear
            else if (r < 0.5) nextWeatherIndex = 1; // Breezy
            else if (r < 0.7) nextWeatherIndex = 2; // Rain
            else if (r < 0.85) nextWeatherIndex = 3; // Storm
            else nextWeatherIndex = 4; // Snow
            
            // UI Update
            const wDisplay = document.getElementById('weather-display');
            const wName = WEATHER_TYPES[currentWeatherIndex];
            wDisplay.innerText = wName + " > " + WEATHER_TYPES[nextWeatherIndex];
        }

        // Calculate Blend Factor (0 to 1 over the interval)
        weatherBlend = weatherTimer / WEATHER_CHANGE_INTERVAL;
        
        // Particle System Logic
        const rainSys = particleSystems[0].mesh;
        const positions = rainSys.geometry.attributes.position.array;
        
        const getOpacity = (idx) => (idx >= 2) ? 0.6 : 0; // Rain/Storm/Snow visible
        const getColor = (idx) => (idx === 4) ? 0xffffff : 0xaaaaaa; // Snow vs Rain
        const getSpeed = (idx) => (idx === 4) ? 0.5 : 2.5;

        const curOp = getOpacity(currentWeatherIndex);
        const nextOp = getOpacity(nextWeatherIndex);
        const finalOp = THREE.MathUtils.lerp(curOp, nextOp, weatherBlend);
        
        rainSys.material.opacity = finalOp;
        
        // Color transition (hard swap usually fine for color, or blend)
        const targetColor = (nextWeatherIndex === 4 || currentWeatherIndex === 4) ? 0xffffff : 0xaaaaaa;
        rainSys.material.color.setHex(targetColor);

        // Physics
        const curSpeed = getSpeed(currentWeatherIndex);
        const nextSpeed = getSpeed(nextWeatherIndex);
        const fallSpeed = THREE.MathUtils.lerp(curSpeed, nextSpeed, weatherBlend);
        
        // Wind
        let windX = (currentWeatherIndex === 3 || nextWeatherIndex === 3) ? 1 : 0; // Storm wind
        if (currentWeatherIndex === 1 || nextWeatherIndex === 1) windX = 0.3; // Breezy

        for(let i=0; i<positions.length; i+=3) {
            positions[i] += windX; 
            positions[i+1] -= fallSpeed;
            if (positions[i+1] < 0) {
                positions[i+1] = 100;
                positions[i] = (Math.random()-0.5)*200;
                positions[i+2] = (Math.random()-0.5)*200;
            }
        }
        rainSys.geometry.attributes.position.needsUpdate = true;
        rainSys.position.x = car.position.x;
        rainSys.position.z = car.position.z;
    }

    function updateCarPhysics(delta) {
        if (keys.ArrowUp || keys.w) speed = Math.min(speed + 0.01, maxSpeed);
        else if (keys.ArrowDown || keys.s) speed = Math.max(speed - 0.01, -maxSpeed/2);
        else speed *= 0.98; 

        if (keys[" "]) speed *= 0.92;

        if (Math.abs(speed) > 0.01) {
            const dir = Math.sign(speed);
            if (keys.ArrowLeft || keys.a) car.rotation.y += turnSpeed * dir;
            if (keys.ArrowRight || keys.d) car.rotation.y -= turnSpeed * dir;
        }

        const vx = Math.sin(car.rotation.y) * speed * 60 * delta;
        const vz = Math.cos(car.rotation.y) * speed * 60 * delta;
        
        const nextX = car.position.x + vx;
        const nextZ = car.position.z + vz;

        // Collision with Building GROUPS
        let crashed = false;
        for (let group of buildingsGroup.children) {
            // Rough check against group position
            const dx = nextX - group.position.x;
            const dz = nextZ - group.position.z;
            if (Math.abs(dx) < 8 && Math.abs(dz) < 8) {
                 crashed = true;
                 break;
            }
        }
        
        // Collision with Trees
        for (let tree of treesGroup.children) {
             const dx = nextX - tree.position.x;
             const dz = nextZ - tree.position.z;
             if (Math.abs(dx) < 1.5 && Math.abs(dz) < 1.5) {
                 crashed = true;
                 break;
             }
        }

        if (crashed) {
            speed = -speed * 0.5;
            takeDamage(5);
            showSafetyMessage();
        } else {
            car.position.x = nextX;
            car.position.z = nextZ;
        }

        const groundH = getTerrainHeight(car.position.x, car.position.z);
        
        if (isHovering) {
            car.position.y += ( (groundH + 8 + Math.sin(time*2)) - car.position.y ) * 0.1;
            const r1 = car.getObjectByName("rotor1");
            const r2 = car.getObjectByName("rotor2");
            const tr = car.getObjectByName("tailRotor");
            if(r1) r1.rotation.y += 0.5;
            if(r2) r2.rotation.y += 0.5;
            if(tr) tr.rotation.x += 0.5;
        } else {
            yVelocity += gravity;
            car.position.y += yVelocity;

            if (car.position.y < groundH + 1) {
                car.position.y = groundH + 1;
                yVelocity = 0;
                
                const lookAhead = getTerrainHeight(car.position.x + vx*5, car.position.z + vz*5);
                if (lookAhead > groundH + 1 && speed > maxSpeed * 0.8) {
                    yVelocity = jumpForce;
                }
            }
            
            const hF = getTerrainHeight(car.position.x + Math.sin(car.rotation.y), car.position.z + Math.cos(car.rotation.y));
            const hR = getTerrainHeight(car.position.x + Math.sin(car.rotation.y-1.57), car.position.z + Math.cos(car.rotation.y-1.57));
            
            const targetPitch = (hF - groundH) * 0.5;
            const targetRoll = (groundH - hR) * 0.5;
            
            if (car.position.y - groundH < 2) {
                car.rotation.x += (targetPitch - car.rotation.x) * 0.1;
                car.rotation.z += (targetRoll - car.rotation.z) * 0.1;
            } else {
                car.rotation.x *= 0.95;
                car.rotation.z *= 0.95;
            }
        }

        const offset = new THREE.Vector3(0, 8, -15).applyMatrix4(car.matrixWorld);
        camera.position.lerp(offset, 0.1);
        camera.lookAt(car.position.x, car.position.y + 2, car.position.z);

        updateDamageEffects();
    }

    function takeDamage(amount) {
        health -= amount;
        if (health < 0) health = 0;
        updateUI();
        if (health === 0) gameOver();
    }

    function showSafetyMessage() {
        const msg = safetyMessages[Math.floor(Math.random() * safetyMessages.length)];
        const el = document.getElementById('safety-alert');
        el.innerHTML = `<div class="safety-box">‚ö†Ô∏è ${msg}</div>`;
        el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 3000);
    }

    function updateDamageEffects() {
        if (health < 50) {
            smokeEmitter.material.opacity = 0.5;
            const positions = smokeEmitter.geometry.attributes.position.array;
            for(let i=0; i<positions.length; i+=3) {
                positions[i+1] += 0.1; 
                if(positions[i+1] > 5) {
                    positions[i] = (Math.random()-0.5);
                    positions[i+1] = 0;
                    positions[i+2] = (Math.random()-0.5);
                }
            }
            smokeEmitter.geometry.attributes.position.needsUpdate = true;
        } else {
            smokeEmitter.material.opacity = 0;
        }

        if (health < 20) {
            fireEmitter.material.opacity = 0.8;
            const positions = fireEmitter.geometry.attributes.position.array;
            for(let i=0; i<positions.length; i+=3) {
                positions[i+1] += 0.2;
                positions[i] += (Math.random()-0.5)*0.1;
                if(positions[i+1] > 3) {
                    positions[i] = (Math.random()-0.5);
                    positions[i+1] = 0;
                    positions[i+2] = (Math.random()-0.5);
                }
            }
            fireEmitter.geometry.attributes.position.needsUpdate = true;
        } else {
            fireEmitter.material.opacity = 0;
        }
    }

    function updateEnvironment(delta) {
        itemsGroup.children.forEach(item => item.rotation.y += 0.02);
        obstaclesGroup.children.forEach(obs => {
            obs.scale.setScalar(1 + Math.sin(time * 5) * 0.1);
        });

        const carPos = car.position;
        
        for (let i = itemsGroup.children.length - 1; i >= 0; i--) {
            const item = itemsGroup.children[i];
            if (carPos.distanceTo(item.position) < 4) {
                itemsGroup.remove(item);
                triggerQuiz();
            }
        }
        
        for (let obs of obstaclesGroup.children) {
            if (carPos.distanceTo(obs.position) < 3) {
                takeDamage(0.5); 
            }
        }
    }

    // --- Quiz & UI ---
    function triggerQuiz() {
        gameActive = false;
        const qIndex = Math.floor(Math.random() * questions.length);
        const currentQ = questions[qIndex];
        const modal = document.getElementById('quiz-modal');
        const qText = document.getElementById('quiz-question');
        const qOptions = document.getElementById('quiz-options');
        const qFeedback = document.getElementById('quiz-feedback');
        const btnContinue = document.getElementById('quiz-continue');

        modal.style.display = 'flex';
        qText.innerText = currentQ.q;
        qOptions.innerHTML = '';
        qFeedback.classList.add('hidden');
        btnContinue.classList.add('hidden');

        [...currentQ.options].sort(() => Math.random() - 0.5).forEach(opt => {
            const btn = document.createElement('button');
            btn.className = 'w-full p-4 bg-gray-700 hover:bg-blue-600 text-left rounded-lg transition-all border border-gray-600';
            btn.innerText = opt;
            btn.onclick = () => {
                if(opt === currentQ.a) {
                    btn.classList.remove('bg-gray-700', 'hover:bg-blue-600');
                    btn.classList.add('bg-green-600');
                    qFeedback.innerText = "Correct! Repairing vehicle...";
                    qFeedback.className = "mt-4 font-bold text-lg text-green-400";
                    score += 100;
                    health = Math.min(100, health + 20); 
                } else {
                    btn.classList.remove('bg-gray-700', 'hover:bg-blue-600');
                    btn.classList.add('bg-red-600');
                    qFeedback.innerText = `Wrong! Answer: ${currentQ.a}`;
                    qFeedback.className = "mt-4 font-bold text-lg text-red-400";
                }
                qFeedback.classList.remove('hidden');
                btnContinue.classList.remove('hidden');
                document.querySelectorAll('#quiz-options button').forEach(b => b.disabled = true);
            };
            qOptions.appendChild(btn);
        });
    }

    function closeQuiz() {
        document.getElementById('quiz-modal').style.display = 'none';
        itemsCollected++;
        updateUI();
        const atomGeo = new THREE.SphereGeometry(1.5, 16, 16);
        const atomMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x0044ff });
        const item = new THREE.Mesh(atomGeo, atomMat);
        setRandomPosition(item);
        item.position.y += 2;
        itemsGroup.add(item);
        
        gameActive = true;
        clock.getDelta(); 
        animate();
    }

    function updateUI() {
        document.getElementById('score-display').innerText = score;
        document.getElementById('level-display').innerText = Math.floor(itemsCollected/5) + 1;
        const bar = document.getElementById('health-bar');
        bar.style.width = health + '%';
        bar.style.background = health > 50 ? '#22c55e' : (health > 20 ? '#eab308' : '#ef4444');
    }

    function gameOver() {
        gameActive = false;
        document.getElementById('game-over-modal').style.display = 'flex';
        document.getElementById('final-score').innerText = "Final Score: " + score;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function setupMobileControls() {
        const handle = (key, state) => (e) => { e.preventDefault(); keys[key] = state; };
        ['up','down','left','right'].forEach(k => {
            const btn = document.getElementById(`btn-${k}`);
            const key = k === 'up' ? 'ArrowUp' : k === 'down' ? 'ArrowDown' : k === 'left' ? 'ArrowLeft' : 'ArrowRight';
            btn.addEventListener('touchstart', handle(key, true));
            btn.addEventListener('touchend', handle(key, false));
        });
    }
</script>
</body>
</html>
