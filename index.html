<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chemistry Cruiser: Ultimate Safety Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* HUD & UI */
        .hud { 
            position: absolute; top: 20px; left: 20px; right: 20px; 
            display: flex; justify-content: space-between; pointer-events: none; z-index: 10;
        }
        .hud-panel {
            background: rgba(15, 23, 42, 0.6); 
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 20px; 
            border-radius: 8px;
            color: #fff;
            transform: skew(-10deg);
            min-width: 100px;
        }
        .hud-text { transform: skew(10deg); font-weight: 800; font-size: 1.2rem; }
        .hud-label { color: #94a3b8; font-size: 0.7rem; text-transform: uppercase; display: block; }
        
        /* Health Bar */
        #health-bar-container {
            width: 200px; height: 10px; background: #333; border-radius: 5px; margin-top: 5px; overflow: hidden;
        }
        #health-bar {
            width: 100%; height: 100%; background: #22c55e; transition: width 0.2s, background 0.2s;
        }

        /* Message Overlay (Safety/Quiz) */
        .modal-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); 
            display: none; justify-content: center; align-items: center; 
            z-index: 50; backdrop-filter: blur(5px);
        }
        .modal-content { 
            background: #1e293b; padding: 2rem; border-radius: 1rem; max-width: 600px; width: 90%; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8); text-align: center; border: 1px solid #334155;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* Start Screen (Garage) */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f172a 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white;
        }
        .vehicle-card {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.2s;
            width: 120px; text-align: center;
        }
        .vehicle-card:hover, .vehicle-card.selected {
            background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; transform: translateY(-5px);
        }
        
        /* Safety Alert */
        #safety-alert {
            position: absolute; top: 20%; width: 100%; text-align: center;
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 40;
        }
        .safety-box {
            display: inline-block; background: rgba(220, 38, 38, 0.9); color: white;
            padding: 15px 30px; border-radius: 50px; font-weight: bold; font-size: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 2px solid white;
        }

        .btn { 
            background: #3b82f6; color: white; padding: 12px 30px; border-radius: 8px; 
            border: none; cursor: pointer; font-weight: bold; margin-top: 20px;
        }
        .btn:hover { background: #2563eb; }

        /* Mobile Controls */
        #mobile-controls {
            display: none; position: absolute; bottom: 20px; width: 100%; height: 150px;
            pointer-events: none; justify-content: space-between; padding: 0 30px; z-index: 20;
        }
        .d-btn {
            pointer-events: auto; width: 60px; height: 60px; background: rgba(255,255,255,0.2);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 24px; border: 1px solid rgba(255,255,255,0.4); backdrop-filter: blur(4px);
        }
        @media (max-width: 768px) { #mobile-controls { display: flex; } }
    </style>
</head>
<body>

<div id="game-container"></div>

<!-- HUD -->
<div class="hud">
    <div class="hud-panel">
        <div class="hud-text">
            <span class="hud-label">Vehicle Condition</span>
            <div id="health-bar-container"><div id="health-bar"></div></div>
        </div>
    </div>
    <div class="hud-panel" style="text-align: right;">
        <div class="hud-text">
            <span class="hud-label">Score / Level</span>
            <span class="hud-value" id="score-display">0</span> <span class="text-gray-400 text-sm">| Lvl <span id="level-display">1</span></span>
        </div>
        <div class="hud-text mt-2 text-sm text-yellow-400" id="weather-display">‚òÄÔ∏è Clear</div>
    </div>
</div>

<!-- Safety Alert Pop-up -->
<div id="safety-alert">
    <div class="safety-box">‚ö†Ô∏è SPEED KILLS - SLOW DOWN!</div>
</div>

<!-- Quiz Modal -->
<div id="quiz-modal" class="modal-overlay">
    <div class="modal-content">
        <h2 class="text-2xl font-bold text-white mb-4" id="quiz-question">Question?</h2>
        <div id="quiz-options" class="grid gap-2"></div>
        <div id="quiz-feedback" class="mt-4 font-bold hidden text-lg"></div>
        <button id="quiz-continue" class="btn hidden w-full" onclick="closeQuiz()">Continue Safely</button>
    </div>
</div>

<!-- Game Over Modal -->
<div id="game-over-modal" class="modal-overlay">
    <div class="modal-content border-red-500">
        <h1 class="text-4xl font-black text-red-500 mb-2">VEHICLE DESTROYED</h1>
        <p class="text-gray-300 mb-6">You drove too fast and ignored safety warnings.</p>
        <div class="text-2xl font-bold mb-6 text-white" id="final-score">Score: 0</div>
        <button class="btn bg-red-600 hover:bg-red-700 w-full" onclick="location.reload()">Back to Garage</button>
    </div>
</div>

<!-- Start Screen / Garage -->
<div id="start-screen">
    <h1 class="text-5xl font-black mb-2 italic bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-green-400">CHEMISTRY CRUISER</h1>
    <p class="text-gray-400 mb-8 tracking-widest text-sm">ULTIMATE SAFETY EDITION</p>
    
    <div class="bg-gray-900/80 p-8 rounded-2xl border border-gray-700 backdrop-blur-md max-w-4xl w-full">
        <h2 class="text-xl font-bold mb-4 text-white">1. Choose Your Vehicle</h2>
        <div class="flex flex-wrap justify-center gap-4 mb-8" id="vehicle-selector">
            <div class="vehicle-card selected" onclick="selectVehicle('sedan', this)">
                <div class="text-3xl mb-2">üöó</div>
                <div class="font-bold text-sm">Sedan</div>
            </div>
            <div class="vehicle-card" onclick="selectVehicle('f1', this)">
                <div class="text-3xl mb-2">üèéÔ∏è</div>
                <div class="font-bold text-sm">F1 Racer</div>
            </div>
            <div class="vehicle-card" onclick="selectVehicle('truck', this)">
                <div class="text-3xl mb-2">üöö</div>
                <div class="font-bold text-sm">Hauler</div>
            </div>
            <div class="vehicle-card" onclick="selectVehicle('van', this)">
                <div class="text-3xl mb-2">üöê</div>
                <div class="font-bold text-sm">Hippy Van</div>
            </div>
            <div class="vehicle-card" onclick="selectVehicle('heli', this)">
                <div class="text-3xl mb-2">üöÅ</div>
                <div class="font-bold text-sm">Heli-Car</div>
            </div>
        </div>

        <h2 class="text-xl font-bold mb-4 text-white">2. Paint Job</h2>
        <div class="flex justify-center gap-4 mb-8">
            <div class="w-10 h-10 rounded-full cursor-pointer border-2 border-white bg-red-500" onclick="vehicleColor=0xff0000"></div>
            <div class="w-10 h-10 rounded-full cursor-pointer border-2 border-gray-600 bg-blue-500" onclick="vehicleColor=0x3b82f6"></div>
            <div class="w-10 h-10 rounded-full cursor-pointer border-2 border-gray-600 bg-green-500" onclick="vehicleColor=0x22c55e"></div>
            <div class="w-10 h-10 rounded-full cursor-pointer border-2 border-gray-600 bg-purple-500" onclick="vehicleColor=0xa855f7"></div>
            <div class="w-10 h-10 rounded-full cursor-pointer border-2 border-gray-600 bg-yellow-500" onclick="vehicleColor=0xeab308"></div>
        </div>

        <button class="btn w-full text-xl py-4 shadow-lg shadow-blue-500/30" onclick="initGame()">START ENGINE</button>
    </div>
</div>

<div id="mobile-controls">
    <div class="flex flex-col gap-2 justify-center">
        <div class="d-btn" id="btn-up">‚ñ≤</div>
        <div class="d-btn" id="btn-down">‚ñº</div>
    </div>
    <div class="flex gap-2 items-end">
        <div class="d-btn" id="btn-left">‚óÄ</div>
        <div class="d-btn" id="btn-right">‚ñ∂</div>
    </div>
</div>

<script>
    // --- Data: Questions ---
    const questions = [
        { q: "Which statement best describes matter?", a: "Anything that has mass and takes up space", options: ["Anything that has mass and takes up space", "Only solids and liquids", "Energy and light", "Anything visible to the eye"] },
        { q: "Protons are located in which part of an atom?", a: "Nucleus", options: ["Electron Cloud", "Nucleus", "Outer Shell", "They orbit the nucleus"] },
        { q: "What is the charge of a neutron?", a: "Neutral (No charge)", options: ["Positive", "Negative", "Neutral (No charge)", "Variable"] },
        { q: "In a solid, particles:", a: "Vibrate in a fixed position", options: ["Move freely and quickly", "Slide past one another", "Vibrate in a fixed position", "Are completely motionless"] },
        { q: "Which state of matter has no fixed shape and no fixed volume?", a: "Gas", options: ["Solid", "Liquid", "Gas", "Plasma"] },
        { q: "A physical change:", a: "Does not change the substance's identity", options: ["Creates a new substance", "Changes the chemical composition", "Is irreversible", "Does not change the substance's identity"] },
        { q: "According to the Law of Conservation of Matter:", a: "Matter is neither created nor destroyed", options: ["Matter is destroyed in fire", "Mass increases during reactions", "Matter is neither created nor destroyed", "Matter turns into pure energy easily"] },
        { q: "A mixture is defined as:", a: "Two or more substances physically combined", options: ["Two or more substances chemically bonded", "Two or more substances physically combined", "A pure substance", "A single element"] },
        { q: "Filtration works because:", a: "It separates based on particle size", options: ["It separates based on magnetism", "It separates based on particle size", "It separates based on boiling point", "It creates a chemical reaction"] },
        { q: "Magnetism can separate:", a: "Iron filings from sand", options: ["Salt from water", "Oil from water", "Iron filings from sand", "Sugar from flour"] },
        { q: "Trail mix is an example of:", a: "Heterogeneous mixture", options: ["Homogeneous mixture", "Compound", "Element", "Heterogeneous mixture"] },
        { q: "Saltwater is an example of:", a: "Homogeneous mixture (Solution)", options: ["Heterogeneous mixture", "Compound", "Homogeneous mixture (Solution)", "Element"] },
        { q: "Burning a log appears to lose mass because:", a: "Gases are released into the air", options: ["The matter is destroyed", "The atoms disappear", "Gases are released into the air", "Fire eats the wood"] },
        { q: "Which is a sign that a chemical reaction has occurred?", a: "Formation of a precipitate or gas", options: ["Change in shape", "Melting", "Formation of a precipitate or gas", "Breaking into pieces"] },
        { q: "The smallest unit of matter that retains the properties of an element is:", a: "Atom", options: ["Molecule", "Atom", "Electron", "Proton"] }
    ];

    const safetyMessages = [
        "Speed Kills - SLOW DOWN!",
        "Eyes on the road!",
        "Watch your stopping distance!",
        "Arrive alive - Don't drink and drive!",
        "Seatbelts save lives!",
        "Beware of aquaplaning in rain!"
    ];

    // --- Game Variables ---
    let scene, camera, renderer, car, cityGroup;
    let itemsGroup, obstaclesGroup, buildingsGroup, tunnelsGroup;
    let particleSystems = []; // Rain, Snow, Smoke
    let smokeEmitter, fireEmitter;
    
    let gameActive = false;
    let score = 0;
    let itemsCollected = 0;
    let level = 1;
    let clock = new THREE.Clock();
    let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false, " ": false };
    
    // Physics
    let speed = 0;
    let maxSpeed = 0.6; // Slower speed
    let turnSpeed = 0.03;
    let yVelocity = 0;
    const gravity = -0.015;
    const jumpForce = 0.4;
    
    // Vehicle State
    let selectedVehicleType = 'sedan';
    let vehicleColor = 0xff0000;
    let health = 100;
    let isHovering = false; // For Heli
    
    // Environment
    const CITY_SIZE = 1500;
    let time = 0; // Total time
    let dayTime = 0; // 0 to 1 cycle
    const dayDuration = 180; // Seconds for full cycle (120s day + 60s night)
    
    // Weather
    const WEATHER_TYPES = ['Clear', 'Windy', 'Rain', 'Storm', 'Snow'];
    let currentWeather = 0;
    let weatherTimer = 0;

    // --- Setup Selection ---
    function selectVehicle(type, el) {
        selectedVehicleType = type;
        document.querySelectorAll('.vehicle-card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
    }

    // --- Terrain Helper ---
    function getTerrainHeight(x, z) {
        // Larger hills for jumping
        return (Math.sin(x * 0.01) * 12 + Math.cos(z * 0.01) * 12) + 
               (Math.sin(x * 0.03) * 4 + Math.cos(z * 0.03) * 4);
    }

    // --- Initialization ---
    function initGame() {
        document.getElementById('start-screen').style.display = 'none';
        
        // Reset Logic
        level = 1; score = 0; itemsCollected = 0; health = 100;
        yVelocity = 0; speed = 0;
        updateUI();
        
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue start
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);

        // Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        const container = document.getElementById('game-container');
        container.innerHTML = ''; 
        container.appendChild(renderer.domElement);

        // Lighting (Day/Night controlled)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.name = "hemiLight";
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.name = "dirLight";
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = true;
        // Large shadow map
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // World Generation
        createEnvironment();
        createCar();
        createParticles(); // Weather + Damage

        // Events
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        setupMobileControls();

        gameActive = true;
        animate();
    }

    function createEnvironment() {
        cityGroup = new THREE.Group();
        buildingsGroup = new THREE.Group();
        tunnelsGroup = new THREE.Group();
        itemsGroup = new THREE.Group();
        obstaclesGroup = new THREE.Group();
        
        // Terrain
        const floorGeo = new THREE.PlaneGeometry(CITY_SIZE, CITY_SIZE, 100, 100);
        const posAttribute = floorGeo.attributes.position;
        for (let i = 0; i < posAttribute.count; i++) {
            const x = posAttribute.getX(i);
            const y = posAttribute.getY(i); 
            const z = getTerrainHeight(x, -y); 
            posAttribute.setZ(i, z);
        }
        floorGeo.computeVertexNormals();
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        cityGroup.add(floor);

        // Buildings (Massive Scale)
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        for (let i = 0; i < 200; i++) {
            const h = Math.random() * 60 + 20; // Taller buildings
            const w = Math.random() * 15 + 10; // Wider
            const d = Math.random() * 15 + 10;
            const x = (Math.random() - 0.5) * CITY_SIZE * 0.8;
            const z = (Math.random() - 0.5) * CITY_SIZE * 0.8;
            
            if (Math.abs(x) < 50 && Math.abs(z) < 50) continue; // Clear spawn

            const groundHeight = getTerrainHeight(x, z);
            const mat = new THREE.MeshStandardMaterial({ 
                color: Math.random() > 0.5 ? 0x1a1a2e : 0x16213e,
                roughness: 0.3
            });
            const building = new THREE.Mesh(boxGeo, mat);
            building.position.set(x, groundHeight + h/2 - 5, z);
            building.scale.set(w, h, d);
            building.castShadow = true;
            building.receiveShadow = true;
            
            // Lit Windows (emissive texture simulated)
            if (Math.random() > 0.2) {
                const win = new THREE.Mesh(boxGeo, new THREE.MeshBasicMaterial({ color: 0xffffcc }));
                win.scale.set(w+0.2, h*0.8, d+0.2);
                win.position.set(x, groundHeight + h*0.5, z);
                win.material.transparent = true;
                win.material.opacity = 0; // Off by default, turned on at night
                win.userData = { isWindow: true };
                buildingsGroup.add(win);
            }
            buildingsGroup.add(building);
        }

        // Tunnels (Simple arches)
        const tunnelGeo = new THREE.TorusGeometry(10, 2, 16, 30, Math.PI);
        const tunnelMat = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide });
        for(let i=0; i<5; i++) {
            const t = new THREE.Mesh(tunnelGeo, tunnelMat);
            const x = (Math.random() - 0.5) * CITY_SIZE * 0.6;
            const z = (Math.random() - 0.5) * CITY_SIZE * 0.6;
            const y = getTerrainHeight(x, z);
            t.position.set(x, y, z);
            t.scale.set(1.5, 1.5, 2);
            t.rotation.y = Math.random() * Math.PI;
            tunnelsGroup.add(t);
        }

        // Items & Obstacles
        spawnObjects();

        cityGroup.add(buildingsGroup);
        cityGroup.add(tunnelsGroup);
        cityGroup.add(itemsGroup);
        cityGroup.add(obstaclesGroup);
        scene.add(cityGroup);
    }

    function spawnObjects() {
        // Atoms
        const atomGeo = new THREE.SphereGeometry(1.5, 16, 16);
        const atomMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x0044ff, emissiveIntensity: 0.8 });
        for(let i=0; i<40; i++) {
            const item = new THREE.Mesh(atomGeo, atomMat);
            setRandomPosition(item);
            item.position.y += 2;
            itemsGroup.add(item);
        }

        // Spikes (Unstable Matter)
        const spikeGeo = new THREE.ConeGeometry(1, 3, 8);
        const spikeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
        for(let i=0; i<30; i++) {
            const obs = new THREE.Mesh(spikeGeo, spikeMat);
            setRandomPosition(obs);
            obstaclesGroup.add(obs);
        }
    }

    function setRandomPosition(mesh) {
        let x = (Math.random() - 0.5) * CITY_SIZE * 0.8;
        let z = (Math.random() - 0.5) * CITY_SIZE * 0.8;
        let y = getTerrainHeight(x, z);
        mesh.position.set(x, y + 1.5, z);
    }

    function createCar() {
        car = new THREE.Group();
        car.userData = { velocity: new THREE.Vector3() };

        let body, wheels = [];

        // Build specific car type
        const colMat = new THREE.MeshStandardMaterial({ color: vehicleColor, metalness: 0.7, roughness: 0.2 });
        const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

        if (selectedVehicleType === 'f1') {
            maxSpeed = 1.0; // Fast
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 5), colMat);
            b.position.y = 0.5;
            car.add(b);
            // Spoiler
            const s = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.8), blackMat);
            s.position.set(0, 1, -2);
            car.add(s);
        } else if (selectedVehicleType === 'truck') {
            maxSpeed = 0.5; // Slow
            const b = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 6), colMat);
            b.position.y = 1.5;
            car.add(b);
            const cab = new THREE.Mesh(new THREE.BoxGeometry(2.6, 2, 2.5), colMat);
            cab.position.set(0, 2, 2);
            car.add(cab);
        } else if (selectedVehicleType === 'heli') {
            maxSpeed = 0.7;
            isHovering = true;
            const b = new THREE.Mesh(new THREE.SphereGeometry(1.5), colMat);
            b.position.y = 2;
            car.add(b);
            // Rotors
            const r = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, 0.5), blackMat);
            r.position.y = 3.6;
            r.name = "rotor";
            car.add(r);
        } else if (selectedVehicleType === 'van') {
            const b = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2, 4.5), colMat);
            b.position.y = 1.2;
            car.add(b);
            // Flower power decal simulation (simple spheres)
            const d = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xff00ff}));
            d.position.set(1.1, 1.5, 0);
            car.add(d);
        } else {
            // Sedan
            const b = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 4), colMat);
            b.position.y = 0.8;
            car.add(b);
            const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 2), blackMat);
            top.position.set(0, 1.6, -0.5);
            car.add(top);
        }

        if (!isHovering) {
            const wGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
            [ {x:-1.2,z:1.5}, {x:1.2,z:1.5}, {x:-1.2,z:-1.5}, {x:1.2,z:-1.5} ].forEach(pos => {
                const w = new THREE.Mesh(wGeo, blackMat);
                w.rotation.z = Math.PI/2;
                w.position.set(pos.x, 0.5, pos.z);
                car.add(w);
            });
        }

        // Lights
        const sl = new THREE.SpotLight(0xffffee, 10, 60, 0.6, 0.5, 1);
        sl.position.set(0, 2, 1);
        sl.target.position.set(0, 0, 20);
        car.add(sl);
        car.add(sl.target);
        
        scene.add(car);

        // Attach Emitters
        const smokeGeo = new THREE.BufferGeometry();
        const smokePos = new Float32Array(50 * 3);
        smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePos, 3));
        const smokeMat = new THREE.PointsMaterial({ color: 0x555555, size: 2, transparent: true, opacity: 0 });
        smokeEmitter = new THREE.Points(smokeGeo, smokeMat);
        car.add(smokeEmitter);

        const fireGeo = new THREE.BufferGeometry();
        const firePos = new Float32Array(50 * 3);
        fireGeo.setAttribute('position', new THREE.BufferAttribute(firePos, 3));
        const fireMat = new THREE.PointsMaterial({ color: 0xff4400, size: 3, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
        fireEmitter = new THREE.Points(fireGeo, fireMat);
        car.add(fireEmitter);
    }

    function createParticles() {
        // Rain/Snow System
        const count = 10000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        for(let i=0; i<count*3; i+=3) {
            pos[i] = (Math.random()-0.5)*200;
            pos[i+1] = Math.random()*100;
            pos[i+2] = (Math.random()-0.5)*200;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.2, transparent: true, opacity: 0 });
        const sys = new THREE.Points(geo, mat);
        scene.add(sys);
        particleSystems.push({ mesh: sys, type: 'weather', vel: new THREE.Vector3(0, -1, 0) });
    }

    // --- Core Game Loop ---
    function animate() {
        if (!gameActive) return;
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        time += delta;
        weatherTimer += delta;

        // Day/Night Cycle
        updateDayNightCycle();
        
        // Weather
        updateWeather(delta);

        // Vehicle Physics
        updateCarPhysics(delta);

        // Environment
        updateEnvironment(delta);

        renderer.render(scene, camera);
    }

    function updateDayNightCycle() {
        // Cycle 0 -> 1 over dayDuration
        const rawTime = (time % dayDuration) / dayDuration;
        
        // Background Color
        let skyColor, fogColor, lightIntensity;
        
        if (rawTime < 0.1) { // Sunrise
            skyColor = new THREE.Color(0xffaa00).lerp(new THREE.Color(0x87CEEB), rawTime * 10);
            lightIntensity = rawTime * 10;
        } else if (rawTime < 0.6) { // Day
            skyColor = new THREE.Color(0x87CEEB);
            lightIntensity = 1;
        } else if (rawTime < 0.7) { // Sunset
            skyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0x0f172a), (rawTime - 0.6) * 10);
            lightIntensity = 1 - (rawTime - 0.6) * 10;
        } else { // Night
            skyColor = new THREE.Color(0x0f172a);
            lightIntensity = 0.1;
        }

        // Apply Weather Tint
        if (currentWeather >= 2) { // Rain/Storm
            skyColor.lerp(new THREE.Color(0x333333), 0.8);
            lightIntensity *= 0.5;
        }

        scene.background = skyColor;
        scene.fog.color = skyColor;
        const sun = scene.getObjectByName("dirLight");
        sun.intensity = lightIntensity;
        sun.position.x = Math.sin(rawTime * Math.PI * 2) * 200;
        sun.position.y = Math.cos(rawTime * Math.PI * 2) * 200;

        // Window Lights
        buildingsGroup.children.forEach(b => {
            if (b.userData.isWindow) {
                b.material.opacity = (rawTime > 0.65 || rawTime < 0.05) ? 0.9 : 0;
            }
        });
    }

    function updateWeather(delta) {
        if (weatherTimer > 30) { // Change weather every 30s
            currentWeather = (currentWeather + 1) % WEATHER_TYPES.length;
            weatherTimer = 0;
            const wName = WEATHER_TYPES[currentWeather];
            const wDisplay = document.getElementById('weather-display');
            wDisplay.innerText = wName;
            
            // Text Color
            if(wName==='Clear') wDisplay.className = 'hud-text mt-2 text-sm text-yellow-400';
            else if(wName==='Rain') wDisplay.className = 'hud-text mt-2 text-sm text-blue-400';
            else if(wName==='Snow') wDisplay.className = 'hud-text mt-2 text-sm text-white';
            else wDisplay.className = 'hud-text mt-2 text-sm text-gray-400';
        }

        const rainSys = particleSystems[0].mesh;
        const positions = rainSys.geometry.attributes.position.array;

        if (currentWeather === 0 || currentWeather === 1) { // Clear/Windy
            rainSys.material.opacity = 0;
        } else {
            rainSys.material.opacity = 0.6;
            rainSys.material.color.setHex(currentWeather === 4 ? 0xffffff : 0xaaaaaa); // Snow white, rain gray
            
            // Update particles
            const fallSpeed = currentWeather === 4 ? 0.5 : 2.5; // Snow slow
            const windX = currentWeather === 3 ? 1 : 0; // Storm wind

            for(let i=0; i<positions.length; i+=3) {
                positions[i] += windX; 
                positions[i+1] -= fallSpeed;
                
                // Reset
                if (positions[i+1] < 0) {
                    positions[i+1] = 100;
                    positions[i] = (Math.random()-0.5)*200;
                    positions[i+2] = (Math.random()-0.5)*200;
                }
            }
            rainSys.geometry.attributes.position.needsUpdate = true;
            rainSys.position.x = car.position.x;
            rainSys.position.z = car.position.z;
        }
    }

    function updateCarPhysics(delta) {
        // 1. Input Acceleration
        if (keys.ArrowUp || keys.w) speed = Math.min(speed + 0.01, maxSpeed);
        else if (keys.ArrowDown || keys.s) speed = Math.max(speed - 0.01, -maxSpeed/2);
        else speed *= 0.98; // Friction

        if (keys[" "]) speed *= 0.92; // Handbrake

        // 2. Turning
        if (Math.abs(speed) > 0.01) {
            const dir = Math.sign(speed);
            if (keys.ArrowLeft || keys.a) car.rotation.y += turnSpeed * dir;
            if (keys.ArrowRight || keys.d) car.rotation.y -= turnSpeed * dir;
        }

        // 3. Move X/Z
        const vx = Math.sin(car.rotation.y) * speed * 60 * delta; // Scale by delta
        const vz = Math.cos(car.rotation.y) * speed * 60 * delta;
        
        const nextX = car.position.x + vx;
        const nextZ = car.position.z + vz;

        // 4. Collision (Solid Buildings)
        let crashed = false;
        for (let b of buildingsGroup.children) {
            if (b.userData.isWindow) continue;
            const dx = nextX - b.position.x;
            const dz = nextZ - b.position.z;
            const minDist = Math.max(b.scale.x, b.scale.z)/2 + 2;
            if (Math.abs(dx) < minDist && Math.abs(dz) < minDist) {
                crashed = true;
                break;
            }
        }

        if (crashed) {
            speed = -speed * 0.5; // Bounce
            takeDamage(10);
            showSafetyMessage();
        } else {
            car.position.x = nextX;
            car.position.z = nextZ;
        }

        // 5. Vertical Physics (Gravity & Jumping)
        const groundH = getTerrainHeight(car.position.x, car.position.z);
        
        if (isHovering) {
            // Heli Logic
            car.position.y += ( (groundH + 8 + Math.sin(time*2)) - car.position.y ) * 0.1;
            // Rotor spin
            const rotor = car.getObjectByName("rotor");
            if(rotor) rotor.rotation.y += 0.5;
        } else {
            // Car Logic
            yVelocity += gravity;
            car.position.y += yVelocity;

            if (car.position.y < groundH + 1) {
                car.position.y = groundH + 1;
                yVelocity = 0;
                
                // Ramp Logic: If speed is high and ground slope is up, add Y velocity
                // Simple approximation: Check height ahead
                const lookAhead = getTerrainHeight(car.position.x + vx*5, car.position.z + vz*5);
                if (lookAhead > groundH + 1 && speed > maxSpeed * 0.8) {
                    // We are hitting a ramp fast
                    yVelocity = jumpForce;
                }
            }
            
            // Tilt logic
            const hF = getTerrainHeight(car.position.x + Math.sin(car.rotation.y), car.position.z + Math.cos(car.rotation.y));
            const hR = getTerrainHeight(car.position.x + Math.sin(car.rotation.y-1.57), car.position.z + Math.cos(car.rotation.y-1.57));
            
            // Smooth tilt
            const targetPitch = (hF - groundH) * 0.5;
            const targetRoll = (groundH - hR) * 0.5;
            
            // Only tilt if near ground
            if (car.position.y - groundH < 2) {
                car.rotation.x += (targetPitch - car.rotation.x) * 0.1;
                car.rotation.z += (targetRoll - car.rotation.z) * 0.1;
            } else {
                // Mid-air straighten
                car.rotation.x *= 0.95;
                car.rotation.z *= 0.95;
            }
        }

        // 6. Camera Follow
        const offset = new THREE.Vector3(0, 8, -15).applyMatrix4(car.matrixWorld);
        camera.position.lerp(offset, 0.1);
        camera.lookAt(car.position.x, car.position.y + 2, car.position.z);

        // 7. Damage Visuals
        updateDamageEffects();
    }

    function takeDamage(amount) {
        health -= amount;
        if (health < 0) health = 0;
        updateUI();
        if (health === 0) gameOver();
    }

    function showSafetyMessage() {
        const msg = safetyMessages[Math.floor(Math.random() * safetyMessages.length)];
        const el = document.getElementById('safety-alert');
        el.innerHTML = `<div class="safety-box">‚ö†Ô∏è ${msg}</div>`;
        el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 3000);
    }

    function updateDamageEffects() {
        // Smoke at < 50%
        if (health < 50) {
            smokeEmitter.material.opacity = 0.5;
            const positions = smokeEmitter.geometry.attributes.position.array;
            for(let i=0; i<positions.length; i+=3) {
                positions[i+1] += 0.1; // Rise
                if(positions[i+1] > 5) {
                    positions[i] = (Math.random()-0.5);
                    positions[i+1] = 0;
                    positions[i+2] = (Math.random()-0.5);
                }
            }
            smokeEmitter.geometry.attributes.position.needsUpdate = true;
        } else {
            smokeEmitter.material.opacity = 0;
        }

        // Fire at < 20%
        if (health < 20) {
            fireEmitter.material.opacity = 0.8;
            const positions = fireEmitter.geometry.attributes.position.array;
            for(let i=0; i<positions.length; i+=3) {
                positions[i+1] += 0.2;
                positions[i] += (Math.random()-0.5)*0.1;
                if(positions[i+1] > 3) {
                    positions[i] = (Math.random()-0.5);
                    positions[i+1] = 0;
                    positions[i+2] = (Math.random()-0.5);
                }
            }
            fireEmitter.geometry.attributes.position.needsUpdate = true;
        } else {
            fireEmitter.material.opacity = 0;
        }
    }

    function updateEnvironment(delta) {
        // Rotate Atoms
        itemsGroup.children.forEach(item => item.rotation.y += 0.02);
        
        // Pulse Obstacles
        obstaclesGroup.children.forEach(obs => {
            obs.scale.setScalar(1 + Math.sin(time * 5) * 0.1);
        });

        // Check Collisions (Items/Spikes)
        const carBox = new THREE.Box3().setFromObject(car);
        
        // Collect
        for (let i = itemsGroup.children.length - 1; i >= 0; i--) {
            const item = itemsGroup.children[i];
            if (car.position.distanceTo(item.position) < 4) {
                itemsGroup.remove(item);
                triggerQuiz();
            }
        }
        
        // Spikes
        for (let obs of obstaclesGroup.children) {
            if (car.position.distanceTo(obs.position) < 3) {
                takeDamage(0.5); // Constant damage if sitting on spike
            }
        }
    }

    // --- Quiz & UI ---
    function triggerQuiz() {
        gameActive = false;
        const qIndex = Math.floor(Math.random() * questions.length);
        const currentQ = questions[qIndex];
        const modal = document.getElementById('quiz-modal');
        const qText = document.getElementById('quiz-question');
        const qOptions = document.getElementById('quiz-options');
        const qFeedback = document.getElementById('quiz-feedback');
        const btnContinue = document.getElementById('quiz-continue');

        modal.style.display = 'flex';
        qText.innerText = currentQ.q;
        qOptions.innerHTML = '';
        qFeedback.classList.add('hidden');
        btnContinue.classList.add('hidden');

        // Shuffle
        [...currentQ.options].sort(() => Math.random() - 0.5).forEach(opt => {
            const btn = document.createElement('button');
            btn.className = 'w-full p-4 bg-gray-700 hover:bg-blue-600 text-left rounded-lg transition-all border border-gray-600';
            btn.innerText = opt;
            btn.onclick = () => {
                if(opt === currentQ.a) {
                    btn.classList.remove('bg-gray-700', 'hover:bg-blue-600');
                    btn.classList.add('bg-green-600');
                    qFeedback.innerText = "Correct! Repairing vehicle...";
                    qFeedback.className = "mt-4 font-bold text-lg text-green-400";
                    score += 100;
                    health = Math.min(100, health + 20); // Repair
                } else {
                    btn.classList.remove('bg-gray-700', 'hover:bg-blue-600');
                    btn.classList.add('bg-red-600');
                    qFeedback.innerText = `Wrong! Answer: ${currentQ.a}`;
                    qFeedback.className = "mt-4 font-bold text-lg text-red-400";
                }
                qFeedback.classList.remove('hidden');
                btnContinue.classList.remove('hidden');
                document.querySelectorAll('#quiz-options button').forEach(b => b.disabled = true);
            };
            qOptions.appendChild(btn);
        });
    }

    function closeQuiz() {
        document.getElementById('quiz-modal').style.display = 'none';
        itemsCollected++;
        updateUI();
        // Respawn Item
        const atomGeo = new THREE.SphereGeometry(1.5, 16, 16);
        const atomMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x0044ff });
        const item = new THREE.Mesh(atomGeo, atomMat);
        setRandomPosition(item);
        item.position.y += 2;
        itemsGroup.add(item);
        
        gameActive = true;
        clock.getDelta(); // clear delta
        animate();
    }

    function updateUI() {
        document.getElementById('score-display').innerText = score;
        document.getElementById('level-display').innerText = Math.floor(itemsCollected/5) + 1;
        const bar = document.getElementById('health-bar');
        bar.style.width = health + '%';
        bar.style.background = health > 50 ? '#22c55e' : (health > 20 ? '#eab308' : '#ef4444');
    }

    function gameOver() {
        gameActive = false;
        document.getElementById('game-over-modal').style.display = 'flex';
        document.getElementById('final-score').innerText = "Final Score: " + score;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function setupMobileControls() {
        const handle = (key, state) => (e) => { e.preventDefault(); keys[key] = state; };
        ['up','down','left','right'].forEach(k => {
            const btn = document.getElementById(`btn-${k}`);
            const key = k === 'up' ? 'ArrowUp' : k === 'down' ? 'ArrowDown' : k === 'left' ? 'ArrowLeft' : 'ArrowRight';
            btn.addEventListener('touchstart', handle(key, true));
            btn.addEventListener('touchend', handle(key, false));
        });
    }
</script>
</body>
</html>
